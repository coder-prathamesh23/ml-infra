trigger: none
pr: none

parameters:
- name: tsStack
  displayName: Terraspace stack
  type: string
  default: s3
- name: tsEnv
  displayName: Environment
  type: string
  default: dev
  values: [dev, stage, prod]
- name: action
  displayName: Action
  type: string
  default: plan
  values: [plan, apply, destroy]
- name: awsRegion
  displayName: AWS Region
  type: string
  default: us-east-1

variables:
- group: MLOpsDevToken   # contains TERRAFORM_CLOUD_TOKEN + AWS_* secrets

stages:
- stage: Terraspace
  displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }})
  jobs:
  - job: Run
    pool:
      name: dataengineering_tf

    steps:
    - checkout: self
      fetchDepth: 0

    - bash: |
        set -euo pipefail

        # Start Docker if systemd is available (self-hosted agents)
        if command -v systemctl >/dev/null 2>&1; then
          sudo systemctl start docker || true
        fi
        sudo docker version

        cd "$(Build.SourcesDirectory)"

        # Detect --platform support (for ARM runners pulling amd64)
        PLAT_FLAG=""
        if sudo docker run --help 2>&1 | grep -q -- '--platform'; then
          PLAT_FLAG="--platform=linux/amd64"
        fi

        # Pull Terraspace image (retry without --platform if first pull fails)
        if ! sudo docker pull $PLAT_FLAG ghcr.io/boltops-tools/terraspace:latest; then
          sudo docker pull ghcr.io/boltops-tools/terraspace:latest
          PLAT_FLAG=""
        fi

        # Build a combined CA bundle (handles corp CAs/MITM proxies)
        CA_TMP="/tmp/combined-ca.pem"
        : >"$CA_TMP"
        for f in \
          /etc/ssl/certs/ca-certificates.crt \
          /etc/pki/tls/certs/ca-bundle.crt \
          /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
        do
          [ -s "$f" ] && cat "$f" >>"$CA_TMP"
        done
        if ls /usr/local/share/ca-certificates/*.crt >/dev/null 2>&1; then
          cat /usr/local/share/ca-certificates/*.crt >>"$CA_TMP"
        fi

        # Materialize Terraform credentials file on the HOST (no heredoc)
        TF_HOST="${TF_CLOUD_HOSTNAME:-tf.puget.com}"
        TF_TOKEN_VALUE="${TF_TOKEN_tf_puget_com:-${TERRAFORM_CLOUD_TOKEN:-}}"
        if [ -z "${TF_TOKEN_VALUE}" ]; then
          echo "ERROR: Terraform token missing. Provide TF_TOKEN_tf_puget_com or TERRAFORM_CLOUD_TOKEN." >&2
          exit 1
        fi
        TFRC_HOST="/tmp/credentials.tfrc.json"
        printf '{\n  "credentials": {\n    "%s": {\n      "token": "%s"\n    }\n  }\n}\n' \
          "$TF_HOST" "$TF_TOKEN_VALUE" > "$TFRC_HOST"

        LIMITS="--pids-limit 4096 --ulimit nproc=4096:8192 --ulimit nofile=65536:65536"
        SECURITY="--security-opt seccomp=unconfined --cap-add=SYS_ADMIN --cap-add=SYS_PTRACE"

        TS_ACTION="${{ parameters.action }}"
        TS_STACK="${{ parameters.tsStack }}"
        TS_ENV_VAL="${{ parameters.tsEnv }}"

        # NOTE: Change -w to /workspace if your Terraspace root is the repo root.
        sudo docker run --rm $PLAT_FLAG $LIMITS $SECURITY \
          --entrypoint /bin/sh \
          -v "$(pwd)":/workspace \
          -v "$CA_TMP":/etc/ssl/certs/ca-corp-bundle.pem:ro \
          -v "$TFRC_HOST":/root/.terraform.d/credentials.tfrc.json:ro \
          -w /workspace/terraspace \
          -e TF_CLOUD_HOSTNAME=tf.puget.com \
          -e TF_TOKEN_tf_puget_com \
          -e TERRAFORM_CLOUD_TOKEN \
          -e AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY \
          -e AWS_SESSION_TOKEN \
          -e AWS_DEFAULT_REGION \
          -e TF_CLI_CONFIG_FILE=/root/.terraform.d/credentials.tfrc.json \
          -e SSL_CERT_FILE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e CURL_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e GIT_SSL_CAINFO=/etc/ssl/certs/ca-corp-bundle.pem \
          -e SSL_CERT_DIR=/etc/ssl/certs \
          -e TS_VERSION_CHECK=0 \
          -e TS_ACTION="$TS_ACTION" \
          -e TS_STACK="$TS_STACK" \
          -e TS_ENV_VAL="$TS_ENV_VAL" \
          ghcr.io/boltops-tools/terraspace:latest \
          -c "
            set -eu

            # --- Trust corporate CA inside the container so Terraform trusts tf.puget.com ---
            if [ -s /etc/ssl/certs/ca-corp-bundle.pem ]; then
              mkdir -p /usr/local/share/ca-certificates
              cp /etc/ssl/certs/ca-corp-bundle.pem /usr/local/share/ca-certificates/zz_corp-ca.crt
              if command -v update-ca-certificates >/dev/null 2>&1; then
                update-ca-certificates
              else
                cat /usr/local/share/ca-certificates/zz_corp-ca.crt >> /etc/ssl/certs/ca-certificates.crt 2>/dev/null || true
              fi
              export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
              export SSL_CERT_DIR=/etc/ssl/certs
              export CURL_CA_BUNDLE=\$SSL_CERT_FILE
              export REQUESTS_CA_BUNDLE=\$SSL_CERT_FILE
              export GIT_SSL_CAINFO=\$SSL_CERT_FILE
            fi
            # --- end CA trust ---

            export PATH=/opt/terraspace/embedded/bin:\$PATH
            export GEM_HOME=/opt/terraspace/embedded/lib/ruby/gems/3.0.0
            export GEM_PATH=\$GEM_HOME
            export BUNDLE_JOBS=1 BUNDLE_RETRY=2

            gem list -i nokogiri >/dev/null 2>&1 || gem install -N nokogiri -v 1.15.4 --platform x86_64-linux
            gem list -i terraspace_plugin_aws >/dev/null 2>&1 || gem install -N terraspace_plugin_aws

            echo '--- Versions ---'
            terraform -version
            /opt/terraspace/embedded/bin/terraspace -v

            STACK=\"\${TS_STACK:-vpc}\"
            ENVN=\"\${TS_ENV_VAL:-dev}\"
            ACTION=\"\${TS_ACTION:-plan}\"

            # Build (no --env here; we use TS_ENV)
            export TS_ENV=\"\$ENVN\"
            /opt/terraspace/embedded/bin/terraspace build \"\$STACK\"

            # ---------- VENDOR MODULES (region-aware) ----------
            REGION=\"\${AWS_REGION:-\${AWS_DEFAULT_REGION:-us-east-1}}\"   # Terraspace cache path uses region
            CACHE_ROOT=\".terraspace-cache/\$REGION/\$ENVN\"
            STACK_DIR=\"\$CACHE_ROOT/stacks/\$STACK\"
            MOD_SRC=\"\$CACHE_ROOT/modules\"

            if [ -d \"\$MOD_SRC\" ] && [ -d \"\$STACK_DIR\" ]; then
              rm -rf \"\$STACK_DIR/modules\"
              mkdir -p \"\$STACK_DIR/modules\"
              cp -a \"\$MOD_SRC/.\" \"\$STACK_DIR/modules/\"
              # Rewrite any '../../modules/...' sources to './modules/...'
              if command -v sed >/dev/null 2>&1; then
                find \"\$STACK_DIR\" -maxdepth 1 -type f -name '*.tf' -print0 | \
                  xargs -0 sed -i -E 's|source[[:space:]]*=[[:space:]]*\"\\.{2}/\\.{2}/modules/|source = \"./modules/|g'
              fi
            fi
            # ---------------------------------------------------

            CACHE=\"\$STACK_DIR\"
            if [ -d \"\$CACHE\" ]; then
              echo '--- terraform init (TFC reconfigure) ---'
              ( cd \"\$CACHE\" && terraform init -reconfigure -upgrade -input=false -no-color )
            fi

            case \"\$ACTION\" in
              plan)
                exec /opt/terraspace/embedded/bin/terraspace plan \"\$STACK\" --env \"\$ENVN\" --no-color
                ;;
              apply)
                exec /opt/terraspace/embedded/bin/terraspace up \"\$STACK\" --env \"\$ENVN\" -y --no-color
                ;;
              destroy)
                exec /opt/terraspace/embedded/bin/terraspace down \"\$STACK\" --env \"\$ENVN\" -y --no-color
                ;;
              *)
                echo 'Invalid action'; exit 1
                ;;
            esac
          "
      displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }}) - CA + noninteractive TFC auth
      env:
        TF_TOKEN_tf_puget_com: $(TERRAFORM_CLOUD_TOKEN)   # token for tf.puget.com
        TERRAFORM_CLOUD_TOKEN: $(TERRAFORM_CLOUD_TOKEN)   # same token (fallback)
        AWS_ACCESS_KEY_ID:     $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_SESSION_TOKEN:     $(AWS_SESSION_TOKEN)       # optional
        AWS_DEFAULT_REGION:    ${{ parameters.awsRegion }}
