trigger: none
pr: none

parameters:
- name: tsStack
  displayName: Terraspace stack
  type: string
  default: s3
- name: tsEnv
  displayName: Environment
  type: string
  default: dev
  values: [dev, stage, prod]
- name: action
  displayName: Action
  type: string
  default: plan
  values: [plan, apply, destroy]
- name: awsRegion
  displayName: AWS Region
  type: string
  default: us-east-1

variables:
- group: MLOpsDevToken   # TFE token + AWS_* secrets

stages:
- stage: Terraspace
  displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }})
  jobs:
  - job: Run
    pool:
      name: dataengineering_tf
    steps:
    - checkout: self
      fetchDepth: 0

    - bash: |
        set -euo pipefail

        # Start Docker if needed
        if command -v systemctl >/dev/null 2>&1; then sudo systemctl start docker || true; fi
        sudo docker version

        cd "$(Build.SourcesDirectory)"

        PLAT_FLAG=""
        if sudo docker run --help 2>&1 | grep -q -- '--platform'; then PLAT_FLAG="--platform=linux/amd64"; fi
        if ! sudo docker pull $PLAT_FLAG ghcr.io/boltops-tools/terraspace:latest; then
          sudo docker pull ghcr.io/boltops-tools/terraspace:latest; PLAT_FLAG=""
        fi

        # Combined CA (system + corp)
        CA_TMP="/tmp/combined-ca.pem"; : >"$CA_TMP"
        for f in /etc/ssl/certs/ca-certificates.crt /etc/pki/tls/certs/ca-bundle.crt /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem; do
          [ -s "$f" ] && cat "$f" >>"$CA_TMP"
        done
        if ls /usr/local/share/ca-certificates/*.crt >/dev/null 2>&1; then
          cat /usr/local/share/ca-certificates/*.crt >>"$CA_TMP"
        fi

        # Terraform Enterprise credentials file on host (mounted RO)
        TF_HOST="${TF_CLOUD_HOSTNAME:-tf.puget.com}"
        TF_TOKEN_VALUE="${TF_TOKEN_tf_puget_com:-${TERRAFORM_CLOUD_TOKEN:-}}"
        if [ -z "${TF_TOKEN_VALUE}" ]; then
          echo "ERROR: Terraform token missing (TF_TOKEN_tf_puget_com/TERRAFORM_CLOUD_TOKEN)." >&2; exit 1
        fi
        TFRC_HOST="/tmp/credentials.tfrc.json"
        printf '{\n  "credentials": {\n    "%s": {\n      "token": "%s"\n    }\n  }\n}\n' "$TF_HOST" "$TF_TOKEN_VALUE" > "$TFRC_HOST"

        LIMITS="--pids-limit 4096 --ulimit nproc=4096:8192 --ulimit nofile=65536:65536"
        SECURITY="--security-opt seccomp=unconfined --cap-add=SYS_ADMIN --cap-add=SYS_PTRACE"

        TS_ACTION="${{ parameters.action }}"
        TS_STACK="${{ parameters.tsStack }}"
        TS_ENV_VAL="${{ parameters.tsEnv }}"

        sudo docker run --rm $PLAT_FLAG $LIMITS $SECURITY \
          --entrypoint /bin/sh \
          -v "$(pwd)":/workspace \
          -v "$CA_TMP":/etc/ssl/certs/ca-corp-bundle.pem:ro \
          -v "$TFRC_HOST":/root/.terraform.d/credentials.tfrc.json:ro \
          -w /workspace/terraspace \
          -e TF_CLOUD_HOSTNAME="$TF_HOST" \
          -e TF_TOKEN_tf_puget_com \
          -e TERRAFORM_CLOUD_TOKEN \
          -e AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY \
          -e AWS_SESSION_TOKEN \
          -e AWS_DEFAULT_REGION \
          -e TF_CLI_CONFIG_FILE=/root/.terraform.d/credentials.tfrc.json \
          -e SSL_CERT_FILE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e CURL_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e GIT_SSL_CAINFO=/etc/ssl/certs/ca-corp-bundle.pem \
          -e SSL_CERT_DIR=/etc/ssl/certs \
          -e TS_VERSION_CHECK=0 \
          -e TS_ACTION="$TS_ACTION" \
          -e TS_STACK="$TS_STACK" \
          -e TS_ENV_VAL="$TS_ENV_VAL" \
          ghcr.io/boltops-tools/terraspace:latest \
          -c '
            set -eu

            # Trust corp CA inside the container
            if [ -s /etc/ssl/certs/ca-corp-bundle.pem ]; then
              mkdir -p /usr/local/share/ca-certificates
              cp /etc/ssl/certs/ca-corp-bundle.pem /usr/local/share/ca-certificates/zz_corp-ca.crt
              if command -v update-ca-certificates >/dev/null 2>&1; then update-ca-certificates
              else cat /usr/local/share/ca-certificates/zz_corp-ca.crt >> /etc/ssl/certs/ca-certificates.crt 2>/dev/null || true
              fi
              export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
              export SSL_CERT_DIR=/etc/ssl/certs
              export CURL_CA_BUNDLE="$SSL_CERT_FILE"
              export REQUESTS_CA_BUNDLE="$SSL_CERT_FILE"
              export GIT_SSL_CAINFO="$SSL_CERT_FILE"
            fi

            export PATH=/opt/terraspace/embedded/bin:$PATH
            export GEM_HOME=/opt/terraspace/embedded/lib/ruby/gems/3.0.0
            export GEM_PATH=$GEM_HOME
            export BUNDLE_JOBS=1 BUNDLE_RETRY=2

            gem list -i nokogiri >/dev/null 2>&1 || gem install -N nokogiri -v 1.15.4 --platform x86_64-linux
            gem list -i terraspace_plugin_aws >/dev/null 2>&1 || gem install -N terraspace_plugin_aws

            echo "--- Versions ---"
            terraform -version
            /opt/terraspace/embedded/bin/terraspace -v

            STACK="${TS_STACK:-vpc}"
            ENVN="${TS_ENV_VAL:-dev}"
            ACTION="${TS_ACTION:-plan}"

            # 1) Build once with Terraspace
            export TS_ENV="$ENVN"
            /opt/terraspace/embedded/bin/terraspace build "$STACK"

            # 2) Locate stack dir (auto-detect region)
            STACK_DIR=$(ls -1d .terraspace-cache/*/"$ENVN"/stacks/"$STACK" 2>/dev/null | head -n1 || true)
            [ -n "$STACK_DIR" ] || { echo "ERROR: cannot locate Terraspace stack dir"; exit 1; }
            ENV_ROOT=$(dirname "$(dirname "$STACK_DIR")")   # .terraspace-cache/<region>/<env>
            MOD_SRC="$ENV_ROOT/modules"

            echo "Using STACK_DIR=$STACK_DIR"
            echo "Using MOD_SRC=$MOD_SRC"

            # 3) Vendor modules + rewrite sources to ./modules/...
            if [ -d "$MOD_SRC" ]; then
              rm -rf "$STACK_DIR/modules"; mkdir -p "$STACK_DIR/modules"
              cp -a "$MOD_SRC/." "$STACK_DIR/modules/"
              find "$STACK_DIR" -maxdepth 1 -type f -name "*.tf" -print0 | xargs -0 sed -i -E \
                "s|source[[:space:]]*=[[:space:]]*\"(\\.\\./)+modules/|source = \"./modules/|g"
            fi

            # 4) Make ALL tfvars visible in stack root
            promote_tfvars_dir () {
              srcdir="$1"
              [ -d "$srcdir" ] || return 0
              find "$srcdir" -maxdepth 1 -type f \( -name "*.tfvars" -o -name "*.tfvars.json" -o -name "*.auto.tfvars" -o -name "*.auto.tfvars.json" \) | while read -r f; do
                base=$(basename "$f")
                case "$base" in
                  *.auto.tfvars|*.auto.tfvars.json) dest="$STACK_DIR/$base" ;;
                  *.tfvars.json) dest="$STACK_DIR/40_${base%.tfvars.json}.auto.tfvars.json" ;;
                  *.tfvars)      dest="$STACK_DIR/40_${base%.tfvars}.auto.tfvars" ;;
                  *)             dest="$STACK_DIR/40_${base}.auto.tfvars" ;;
                esac
                cp -a "$f" "$dest" && echo "  + TFVARS(promoted): $(basename "$dest")"
              done
            }

            # Terraspace-generated tfvars (stack/env)
            promote_tfvars_dir "$STACK_DIR/tfvars"
            promote_tfvars_dir "$ENV_ROOT/tfvars"

            # Repo tfvars (base/env/stack/etc.)
            copy_tfvar () {
              src="$1"
              base=$(basename "$src")
              case "$base" in
                *.tfvars.json) dest="$STACK_DIR/50_${base%.tfvars.json}.auto.tfvars.json" ;;
                *.tfvars)      dest="$STACK_DIR/50_${base%.tfvars}.auto.tfvars" ;;
                *)             dest="$STACK_DIR/50_${base}.auto.tfvars" ;;
              esac
              cp -a "$src" "$dest" && echo "  + TFVARS(repo): $(basename "$dest")"
            }
            FOUND=0
            for f in $(find /workspace -type f \
                         \( -name "*${ENVN}*.tfvars" -o -name "*${ENVN}*.tfvars.json" \
                            -o -name "*${STACK}*.tfvars" -o -name "*${STACK}*.tfvars.json" \
                            -o -name "*base*.tfvars" -o -name "*base*.tfvars.json" \
                            -o -name "terraform.tfvars" \) \
                         ! -path "*/.terraspace-cache/*" | sort); do
              copy_tfvar "$f"; FOUND=1
            done
            if [ "$FOUND" -eq 0 ]; then
              for f in $(find /workspace -type f \( -name "*.tfvars" -o -name "*.tfvars.json" \) \
                         ! -path "*/.terraspace-cache/*" | sort); do
                copy_tfvar "$f"
              done
            fi

            # Convert any TF_VAR_* envs into a tfvars file (remote runs won t see pipeline env)
            TF_ENV_FILE="$STACK_DIR/90_tf_env.auto.tfvars"
            : > "$TF_ENV_FILE"
            env | grep "^TF_VAR_" | while IFS="=" read -r name value; do
              key="${name#TF_VAR_}"
              esc=$(printf "%s" "$value" | sed "s/\"/\\\\\"/g")
              printf "%s = \"%s\"\n" "$key" "$esc" >> "$TF_ENV_FILE"
            done
            [ -s "$TF_ENV_FILE" ] || rm -f "$TF_ENV_FILE"

            echo "TFVARS present in stack root (final):"
            ls -1 "$STACK_DIR"/*.tfvars* 2>/dev/null || echo "  (none)"

            # 5) Build ordered -var-file list from EVERY tfvars in stack root
            cd "$STACK_DIR"
            VAR_ARGS=""
            for vf in $(ls -1 *.tfvars* 2>/dev/null | sort -V); do
              VAR_ARGS="$VAR_ARGS -var-file=$vf"
            done
            echo "Using -var-file args:$VAR_ARGS"

            terraform init -input=false -no-color
            case "$ACTION" in
              plan)    eval "terraform plan    -input=false -no-color $VAR_ARGS" ;;
              apply)   eval "terraform apply   -input=false -no-color -auto-approve $VAR_ARGS" ;;
              destroy) eval "terraform destroy -input=false -no-color -auto-approve $VAR_ARGS" ;;
              *) echo "Invalid action: $ACTION"; exit 1 ;;
            esac
          '
      displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }}) - vendoring + explicit tfvars ordering
      env:
        TF_TOKEN_tf_puget_com: $(TERRAFORM_CLOUD_TOKEN)
        TERRAFORM_CLOUD_TOKEN: $(TERRAFORM_CLOUD_TOKEN)
        # Optional: define TF_VAR_* here (will be written into 90_tf_env.auto.tfvars)
        # TF_VAR_bucket_name: my-dev-bucket-123
        AWS_ACCESS_KEY_ID:     $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_SESSION_TOKEN:     $(AWS_SESSION_TOKEN)
        AWS_DEFAULT_REGION:    ${{ parameters.awsRegion }}
