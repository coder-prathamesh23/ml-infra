trigger: none
pr: none

parameters:
- name: tsStack
  displayName: Terraspace stack
  type: string
  default: s3
- name: tsEnv
  displayName: Environment
  type: string
  default: dev
  values: [dev, stage, prod]
- name: action
  displayName: Action
  type: string
  default: plan
  values: [plan, apply, destroy]
- name: awsRegion
  displayName: AWS Region
  type: string
  default: us-east-1

variables:
- group: MLOpsDevToken   # TERRAFORM_CLOUD_TOKEN + AWS_* secrets

stages:
- stage: Terraspace
  displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }})
  jobs:
  - job: Run
    pool:
      name: dataengineering_tf

    steps:
    - checkout: self
      fetchDepth: 0

    - bash: |
        set -euo pipefail

        if command -v systemctl >/dev/null 2>&1; then
          sudo systemctl start docker || true
        fi
        sudo docker version

        cd "$(Build.SourcesDirectory)"

        PLAT_FLAG=""
        if sudo docker run --help 2>&1 | grep -q -- '--platform'; then
          PLAT_FLAG="--platform=linux/amd64"
        fi

        if ! sudo docker pull $PLAT_FLAG ghcr.io/boltops-tools/terraspace:latest; then
          sudo docker pull ghcr.io/boltops-tools/terraspace:latest
          PLAT_FLAG=""
        fi

        # Combined CA (system + corp)
        CA_TMP="/tmp/combined-ca.pem"
        : >"$CA_TMP"
        for f in \
          /etc/ssl/certs/ca-certificates.crt \
          /etc/pki/tls/certs/ca-bundle.crt \
          /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem
        do [ -s "$f" ] && cat "$f" >>"$CA_TMP"; done
        if ls /usr/local/share/ca-certificates/*.crt >/dev/null 2>&1; then
          cat /usr/local/share/ca-certificates/*.crt >>"$CA_TMP"
        fi

        # Terraform Cloud credentials (host file -> mounted RO)
        TF_HOST="${TF_CLOUD_HOSTNAME:-tf.puget.com}"
        TF_TOKEN_VALUE="${TF_TOKEN_tf_puget_com:-${TERRAFORM_CLOUD_TOKEN:-}}"
        if [ -z "$TF_TOKEN_VALUE" ]; then
          echo "ERROR: Terraform token missing. Provide TF_TOKEN_tf_puget_com or TERRAFORM_CLOUD_TOKEN." >&2
          exit 1
        fi
        TFRC_HOST="/tmp/credentials.tfrc.json"
        printf '{\n  "credentials": {\n    "%s": {\n      "token": "%s"\n    }\n  }\n}\n' \
          "$TF_HOST" "$TF_TOKEN_VALUE" > "$TFRC_HOST"

        LIMITS="--pids-limit 4096 --ulimit nproc=4096:8192 --ulimit nofile=65536:65536"
        SECURITY="--security-opt seccomp=unconfined --cap-add=SYS_ADMIN --cap-add=SYS_PTRACE"

        TS_ACTION="${{ parameters.action }}"
        TS_STACK="${{ parameters.tsStack }}"
        TS_ENV_VAL="${{ parameters.tsEnv }}"

        sudo docker run --rm $PLAT_FLAG $LIMITS $SECURITY \
          --entrypoint /bin/sh \
          -v "$(pwd)":/workspace \
          -v "$CA_TMP":/etc/ssl/certs/ca-corp-bundle.pem:ro \
          -v "$TFRC_HOST":/root/.terraform.d/credentials.tfrc.json:ro \
          -w /workspace/terraspace \
          -e TF_CLOUD_HOSTNAME="$TF_HOST" \
          -e TF_TOKEN_tf_puget_com \
          -e TERRAFORM_CLOUD_TOKEN \
          -e AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY \
          -e AWS_SESSION_TOKEN \
          -e AWS_DEFAULT_REGION \
          -e TF_CLI_CONFIG_FILE=/root/.terraform.d/credentials.tfrc.json \
          -e SSL_CERT_FILE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e CURL_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e GIT_SSL_CAINFO=/etc/ssl/certs/ca-corp-bundle.pem \
          -e SSL_CERT_DIR=/etc/ssl/certs \
          -e TS_VERSION_CHECK=0 \
          -e TS_ACTION="$TS_ACTION" \
          -e TS_STACK="$TS_STACK" \
          -e TS_ENV_VAL="$TS_ENV_VAL" \
          ghcr.io/boltops-tools/terraspace:latest \
          -c "
            set -eu

            # Trust corp CA inside the container
            if [ -s /etc/ssl/certs/ca-corp-bundle.pem ]; then
              mkdir -p /usr/local/share/ca-certificates
              cp /etc/ssl/certs/ca-corp-bundle.pem /usr/local/share/ca-certificates/zz_corp-ca.crt
              if command -v update-ca-certificates >/dev/null 2>&1; then
                update-ca-certificates
              else
                cat /usr/local/share/ca-certificates/zz_corp-ca.crt >> /etc/ssl/certs/ca-certificates.crt 2>/dev/null || true
              fi
              export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
              export SSL_CERT_DIR=/etc/ssl/certs
              export CURL_CA_BUNDLE=\$SSL_CERT_FILE
              export REQUESTS_CA_BUNDLE=\$SSL_CERT_FILE
              export GIT_SSL_CAINFO=\$SSL_CERT_FILE
            fi

            export PATH=/opt/terraspace/embedded/bin:\$PATH
            export GEM_HOME=/opt/terraspace/embedded/lib/ruby/gems/3.0.0
            export GEM_PATH=\$GEM_HOME
            export BUNDLE_JOBS=1 BUNDLE_RETRY=2

            gem list -i nokogiri >/dev/null 2>&1 || gem install -N nokogiri -v 1.15.4 --platform x86_64-linux
            gem list -i terraspace_plugin_aws >/dev/null 2>&1 || gem install -N terraspace_plugin_aws

            echo '--- Versions ---'
            terraform -version
            /opt/terraspace/embedded/bin/terraspace -v

            STACK=\"\${TS_STACK:-vpc}\"
            ENVN=\"\${TS_ENV_VAL:-dev}\"
            ACTION=\"\${TS_ACTION:-plan}\"

            # Build (TS_ENV controls env)
            export TS_ENV=\"\$ENVN\"
            /opt/terraspace/embedded/bin/terraspace build \"\$STACK\"

            # Locate actual cache paths (auto-detect region correctly)
            STACK_DIR=\$(ls -1d .terraspace-cache/*/\"\$ENVN\"/stacks/\"\$STACK\" 2>/dev/null | head -n1 || true)
            if [ -z \"\$STACK_DIR\" ]; then
              echo 'ERROR: could not locate Terraspace stack dir in cache'; exit 1
            fi
            # ENV_ROOT = .terraspace-cache/<region>/<env>
            ENV_ROOT=\$(dirname \"\$(dirname \"\$STACK_DIR\")\")
            MOD_SRC=\"\$ENV_ROOT/modules\"

            echo \"Using STACK_DIR=\$STACK_DIR\"
            echo \"Using MOD_SRC=\$MOD_SRC\"

            # Vendor all modules under the stack folder and rewrite sources
            if [ -d \"\$MOD_SRC\" ]; then
              rm -rf \"\$STACK_DIR/modules\"
              mkdir -p \"\$STACK_DIR/modules\"
              cp -a \"\$MOD_SRC/.\" \"\$STACK_DIR/modules/\"

              # Rewrite ANY relative '../../modules/...' or '../modules/...' to './modules/...'
              for f in \"\$STACK_DIR\"/*.tf; do
                [ -f \"\$f\" ] || continue
                # collapse any sequence of ../ that ends with modules/
                sed -i -E 's|source[[:space:]]*=[[:space:]]*\"(\\.\\./)+modules/|source = \"./modules/|g' \"\$f\"
                sed -i -E 's|source[[:space:]]*=[[:space:]]*\"\\./modules/|source = \"./modules/|g' \"\$f\"
              done
            fi

            # Re-init in the modified stack dir (so TFC uploads the fixed tree)
            if [ -d \"\$STACK_DIR\" ]; then
              echo '--- terraform init (TFC reconfigure after vendoring) ---'
              ( cd \"\$STACK_DIR\" && terraform init -reconfigure -upgrade -input=false -no-color )
            fi

            case \"\$ACTION\" in
              plan)
                # Terraspace handles remote ops + streaming; keep using it.
                exec /opt/terraspace/embedded/bin/terraspace plan \"\$STACK\" --env \"\$ENVN\" --no-color
                ;;
              apply)
                exec /opt/terraspace/embedded/bin/terraspace up \"\$STACK\" --env \"\$ENVN\" -y --no-color
                ;;
              destroy)
                exec /opt/terraspace/embedded/bin/terraspace down \"\$STACK\" --env \"\$ENVN\" -y --no-color
                ;;
              *)
                echo 'Invalid action'; exit 1
                ;;
            esac
          "
      displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }}) - vendored modules for TFC
      env:
        TF_TOKEN_tf_puget_com: $(TERRAFORM_CLOUD_TOKEN)
        TERRAFORM_CLOUD_TOKEN: $(TERRAFORM_CLOUD_TOKEN)
        AWS_ACCESS_KEY_ID:     $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_SESSION_TOKEN:     $(AWS_SESSION_TOKEN)
        AWS_DEFAULT_REGION:    ${{ parameters.awsRegion }}
