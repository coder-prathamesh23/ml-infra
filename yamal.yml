trigger: none
pr: none

parameters:
- name: tsStack
  displayName: Terraspace stack
  type: string
  default: s3
- name: tsEnv
  displayName: Environment
  type: string
  default: dev
  values: [dev, stage, prod]
- name: action
  displayName: Action
  type: string
  default: plan
  values: [plan, apply, destroy]
- name: awsRegion
  displayName: AWS Region
  type: string
  default: us-east-1

variables:
- group: MLOpsDevToken   # TFE token + AWS_* secrets

stages:
- stage: Terraspace
  displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }})
  jobs:
  - job: Run
    pool:
      name: dataengineering_tf
    steps:
    - checkout: self
      fetchDepth: 0

    - bash: |
        set -euo pipefail

        # Start Docker if needed
        if command -v systemctl >/dev/null 2>&1; then sudo systemctl start docker || true; fi
        sudo docker version

        cd "$(Build.SourcesDirectory)"

        PLAT_FLAG=""
        if sudo docker run --help 2>&1 | grep -q -- '--platform'; then PLAT_FLAG="--platform=linux/amd64"; fi
        if ! sudo docker pull $PLAT_FLAG ghcr.io/boltops-tools/terraspace:latest; then
          sudo docker pull ghcr.io/boltops-tools/terraspace:latest; PLAT_FLAG=""
        fi

        # Combined CA (system + corp)
        CA_TMP="/tmp/combined-ca.pem"; : >"$CA_TMP"
        for f in /etc/ssl/certs/ca-certificates.crt /etc/pki/tls/certs/ca-bundle.crt /etc/pki/ca-trust/extracted/pem/tls-ca-bundle.pem; do
          [ -s "$f" ] && cat "$f" >>"$CA_TMP"
        done
        if ls /usr/local/share/ca-certificates/*.crt >/dev/null 2>&1; then
          cat /usr/local/share/ca-certificates/*.crt >>"$CA_TMP"
        fi

        # Terraform Enterprise credentials file on host (mounted RO)
        TF_HOST="${TF_CLOUD_HOSTNAME:-tf.puget.com}"
        TF_TOKEN_VALUE="${TF_TOKEN_tf_puget_com:-${TERRAFORM_CLOUD_TOKEN:-}}"
        if [ -z "${TF_TOKEN_VALUE}" ]; then
          echo "ERROR: Terraform token missing (TF_TOKEN_tf_puget_com/TERRAFORM_CLOUD_TOKEN)." >&2; exit 1
        fi
        TFRC_HOST="/tmp/credentials.tfrc.json"
        printf '{\n  "credentials": {\n    "%s": {\n      "token": "%s"\n    }\n  }\n}\n' "$TF_HOST" "$TF_TOKEN_VALUE" > "$TFRC_HOST"

        LIMITS="--pids-limit 4096 --ulimit nproc=4096:8192 --ulimit nofile=65536:65536"
        SECURITY="--security-opt seccomp=unconfined --cap-add=SYS_ADMIN --cap-add=SYS_PTRACE"

        TS_ACTION="${{ parameters.action }}"
        TS_STACK="${{ parameters.tsStack }}"
        TS_ENV_VAL="${{ parameters.tsEnv }}"

        sudo docker run --rm $PLAT_FLAG $LIMITS $SECURITY \
          --entrypoint /bin/sh \
          -v "$(pwd)":/workspace \
          -v "$CA_TMP":/etc/ssl/certs/ca-corp-bundle.pem:ro \
          -v "$TFRC_HOST":/root/.terraform.d/credentials.tfrc.json:ro \
          -w /workspace/terraspace \
          -e TF_CLOUD_HOSTNAME="$TF_HOST" \
          -e TF_TOKEN_tf_puget_com \
          -e TERRAFORM_CLOUD_TOKEN \
          -e AWS_ACCESS_KEY_ID \
          -e AWS_SECRET_ACCESS_KEY \
          -e AWS_SESSION_TOKEN \
          -e AWS_DEFAULT_REGION \
          -e TF_CLI_CONFIG_FILE=/root/.terraform.d/credentials.tfrc.json \
          -e SSL_CERT_FILE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e CURL_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e REQUESTS_CA_BUNDLE=/etc/ssl/certs/ca-corp-bundle.pem \
          -e GIT_SSL_CAINFO=/etc/ssl/certs/ca-corp-bundle.pem \
          -e SSL_CERT_DIR=/etc/ssl/certs \
          -e TS_VERSION_CHECK=0 \
          -e TS_ACTION="$TS_ACTION" \
          -e TS_STACK="$TS_STACK" \
          -e TS_ENV_VAL="$TS_ENV_VAL" \
          ghcr.io/boltops-tools/terraspace:latest \
          -c '
            set -eu

            # Trust corp CA inside the container
            if [ -s /etc/ssl/certs/ca-corp-bundle.pem ]; then
              mkdir -p /usr/local/share/ca-certificates
              cp /etc/ssl/certs/ca-corp-bundle.pem /usr/local/share/ca-certificates/zz_corp-ca.crt
              if command -v update-ca-certificates >/dev/null 2>&1; then update-ca-certificates
              else cat /usr/local/share/ca-certificates/zz_corp-ca.crt >> /etc/ssl/certs/ca-certificates.crt 2>/dev/null || true
              fi
              export SSL_CERT_FILE=/etc/ssl/certs/ca-certificates.crt
              export SSL_CERT_DIR=/etc/ssl/certs
              export CURL_CA_BUNDLE="$SSL_CERT_FILE"
              export REQUESTS_CA_BUNDLE="$SSL_CERT_FILE"
              export GIT_SSL_CAINFO="$SSL_CERT_FILE"
            fi

            export PATH=/opt/terraspace/embedded/bin:$PATH
            export GEM_HOME=/opt/terraspace/embedded/lib/ruby/gems/3.0.0
            export GEM_PATH=$GEM_HOME
            export BUNDLE_JOBS=1 BUNDLE_RETRY=2

            gem list -i nokogiri >/dev/null 2>&1 || gem install -N nokogiri -v 1.15.4 --platform x86_64-linux
            gem list -i terraspace_plugin_aws >/dev/null 2>&1 || gem install -N terraspace_plugin_aws

            echo "--- Versions ---"
            terraform -version
            /opt/terraspace/embedded/bin/terraspace -v

            STACK="${TS_STACK:-vpc}"
            ENVN="${TS_ENV_VAL:-dev}"
            ACTION="${TS_ACTION:-plan}"

            # 1) Build once with Terraspace
            export TS_ENV="$ENVN"
            /opt/terraspace/embedded/bin/terraspace build "$STACK"

            # 2) Locate stack dir (auto-detect region)
            STACK_DIR=$(ls -1d .terraspace-cache/*/"$ENVN"/stacks/"$STACK" 2>/dev/null | head -n1 || true)
            [ -n "$STACK_DIR" ] || { echo "ERROR: cannot locate Terraspace stack dir"; exit 1; }
            ENV_ROOT=$(dirname "$(dirname "$STACK_DIR")")
            MOD_SRC="$ENV_ROOT/modules"

            echo "Using STACK_DIR=$STACK_DIR"
            echo "Using MOD_SRC=$MOD_SRC"

            # 3) Vendor modules into stack and rewrite all module sources to ./modules/...
            if [ -d "$MOD_SRC" ]; then
              rm -rf "$STACK_DIR/modules"; mkdir -p "$STACK_DIR/modules"
              cp -a "$MOD_SRC/." "$STACK_DIR/modules/"
              find "$STACK_DIR" -maxdepth 1 -type f -name "*.tf" -print0 | xargs -0 sed -i -E \
                "s|source[[:space:]]*=[[:space:]]*\"(\\.\\./)+modules/|source = \"./modules/|g"
            fi

            # 4) Make sure correct tfvars are in the stack root (auto-loaded by Terraform/TFC)
            #    a) Promote any build-generated tfvars under stack/tfvars/
            if [ -d "$STACK_DIR/tfvars" ]; then
              while IFS= read -r -d "" f; do
                base=$(basename "$f")
                case "$base" in
                  terraform.tfvars|*.auto.tfvars|*.auto.tfvars.json)
                    dest="$STACK_DIR/$base"
                    ;;
                  *.tfvars.json)
                    dest="$STACK_DIR/40_${base%.tfvars.json}.auto.tfvars.json"
                    ;;
                  *.tfvars)
                    dest="$STACK_DIR/40_${base%.tfvars}.auto.tfvars"
                    ;;
                  *)
                    continue
                    ;;
                esac
                cp -a "$f" "$dest"
                echo "  + from build: $(basename "$dest")"
              done < <(find "$STACK_DIR/tfvars" -maxdepth 1 -type f \( -name "*.tfvars" -o -name "*.tfvars.json" -o -name "*.auto.tfvars" -o -name "*.auto.tfvars.json" -o -name "terraform.tfvars" \) -print0)
            fi

            #    b) Only copy repo tfvars that belong to THIS stack
            for d in \
              "/workspace/app/stacks/$STACK/tfvars" \
              "/workspace/stacks/$STACK/tfvars" \
              "/workspace/terraspace/app/stacks/$STACK/tfvars" \
              "/workspace/terraspace/stacks/$STACK/tfvars"
            do
              [ -d "$d" ] || continue
              while IFS= read -r -d "" f; do
                base=$(basename "$f")
                case "$base" in
                  # prefer env-specific and common names
                  "${ENVN}.tfvars"|"${ENVN}.tfvars.json"|terraform.tfvars|base.tfvars|common.tfvars|*.auto.tfvars|*.auto.tfvars.json)
                    ;;
                  *)
                    # skip unrelated files in that folder
                    continue
                    ;;
                esac
                case "$base" in
                  terraform.tfvars|*.auto.tfvars|*.auto.tfvars.json)
                    dest="$STACK_DIR/$base"
                    ;;
                  *.tfvars.json)
                    dest="$STACK_DIR/50_${base%.tfvars.json}.auto.tfvars.json"
                    ;;
                  *.tfvars)
                    dest="$STACK_DIR/50_${base%.tfvars}.auto.tfvars"
                    ;;
                esac
                cp -a "$f" "$dest"
                echo "  + from repo:  $(basename "$dest")"
              done < <(find "$d" -maxdepth 1 -type f -print0)
            done

            echo "== tfvars present in stack root =="
            ls -1 "$STACK_DIR"/*.tfvars* 2>/dev/null || echo "  (none)"

            # 5) Run Terraform directly in built stack (CLI-driven TFC)
            cd "$STACK_DIR"
            terraform init -input=false -no-color
            case "$ACTION" in
              plan)    terraform plan    -input=false -no-color ;;
              apply)   terraform apply   -input=false -no-color -auto-approve ;;
              destroy) terraform destroy -input=false -no-color -auto-approve ;;
              *) echo "Invalid action: $ACTION"; exit 1 ;;
            esac
          '
      displayName: Terraspace ${{ parameters.action }} (${{ parameters.tsStack }} / ${{ parameters.tsEnv }}) - module vendoring + stack/env tfvars only
      env:
        TF_TOKEN_tf_puget_com: $(TERRAFORM_CLOUD_TOKEN)
        TERRAFORM_CLOUD_TOKEN: $(TERRAFORM_CLOUD_TOKEN)
        AWS_ACCESS_KEY_ID:     $(AWS_ACCESS_KEY_ID)
        AWS_SECRET_ACCESS_KEY: $(AWS_SECRET_ACCESS_KEY)
        AWS_SESSION_TOKEN:     $(AWS_SESSION_TOKEN)
        AWS_DEFAULT_REGION:    ${{ parameters.awsRegion }}
